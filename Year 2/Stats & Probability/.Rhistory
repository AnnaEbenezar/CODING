my.ConditionalMeanAndVar = function(x, data)  {
x_data <- subset(data, X == x)
y_mean <- sum(x_data$Y * (x_data$Prob / sum(x_data$Prob)))
y_var <- sum((x_data$Y - y_mean)^ 2 * (x_data$Prob / sum(x_data$Prob)))
return(c(mean = y_mean, variance = y_var))
}
dim(Joint) <- c(4,3)
Joint
data <- data.frame(X = rep(1:3, each = 4), Y = rep(1:4, times=3), Prob = as.vector(Joint))
for(x in 1:3) {
cat(x, ":", 'MEAN | VARIANCE', '\n')
cat("   ", my.ConditionalMeanAndVar(x, data),'\n')
}
Joint = matrix(c(0.01,0.02,0.25,0.02,0.03,0.20,0.02,0.10,
0.05,0.15,0.10,0.05),nrow=4,ncol=3, byrow=TRUE)
my.ConditionalMeanAndVar = function(x, data)  {
x_data <- subset(data, X == x)
y_mean <- sum(x_data$Y * (x_data$Prob / sum(x_data$Prob)))
y_var <- sum((x_data$Y - y_mean)^ 2 * (x_data$Prob / sum(x_data$Prob)))
return(c(mean = y_mean, variance = y_var))
}
dim(Joint) <- c(4,3)
Joint
data <- data.frame(X = rep(1:3, each = 4), Y = rep(1:4, times=3), Prob = as.vector(Joint))
print.data.frame(data)
for(x in 1:3) {
cat(x, ":", 'MEAN | VARIANCE', '\n')
cat("   ", my.ConditionalMeanAndVar(x, data),'\n')
}
Joint = matrix(c(0.01,0.02,0.25,0.02,0.03,0.20,0.02,0.10,
0.05,0.15,0.10,0.05),nrow=4,ncol=3, byrow=TRUE)
my.ConditionalMeanAndVar = function(x, data)  {
x_data <- subset(data, X == x)
y_mean <- sum(x_data$Y * (x_data$Prob / sum(x_data$Prob)))
y_var <- sum((x_data$Y - y_mean)^ 2 * (x_data$Prob / sum(x_data$Prob)))
return(c(mean = y_mean, variance = y_var))
}
dim(Joint) <- c(4,3)
Joint
data <- data.frame(X = rep(1:3, each = 4), Y = rep(1:4, times=3), Prob = as.vector(Joint))
print.data.frame(data)
cat("Y if X is equal to:")
for(x in 1:3) {
cat(x, ":", 'MEAN | VARIANCE', '\n')
cat("   ", my.ConditionalMeanAndVar(x, data),'\n')
}
#data given
Joint = matrix(c(0.01,0.02,0.25,0.02,0.03,0.20,0.02,0.10,
0.05,0.15,0.10,0.05),nrow=4,ncol=3, byrow=TRUE)
my.ConditionalMeanAndVar = function(x, data)  {
x_data <- subset(data, X == x)
y_mean <- sum(x_data$Y * (x_data$Prob / sum(x_data$Prob)))
y_var <- sum((x_data$Y - y_mean)^ 2 * (x_data$Prob / sum(x_data$Prob)))
return(c(mean = y_mean, variance = y_var))
}
dim(Joint) <- c(4,3)
Joint
data <- data.frame(X = rep(1:3, each = 4), Y = rep(1:4, times=3), Prob = as.vector(Joint))
print.data.frame(data)
cat("Y if X is equal to: \n")
for(x in 1:3) {
cat(x, ":", 'MEAN | VARIANCE', '\n')
cat("   ", my.ConditionalMeanAndVar(x, data),'\n')
print(my.ConditionalMeanAndVar(x, data))
}
#data given
Joint = matrix(c(0.01,0.02,0.25,0.02,0.03,0.20,0.02,0.10,
0.05,0.15,0.10,0.05),nrow=4,ncol=3, byrow=TRUE)
my.ConditionalMeanAndVar = function(x, data)  {
x_data <- subset(data, X == x)
y_mean <- sum(x_data$Y * (x_data$Prob / sum(x_data$Prob)))
y_var <- sum((x_data$Y - y_mean)^ 2 * (x_data$Prob / sum(x_data$Prob)))
return(c(mean = y_mean, variance = y_var))
}
dim(Joint) <- c(4,3)
Joint
data <- data.frame(X = rep(1:3, each = 4), Y = rep(1:4, times=3), Prob = as.vector(Joint))
print.data.frame(data)
cat("Y if X is equal to: \n")
for(x in 1:3) {
#cat(x, ":", 'MEAN | VARIANCE', '\n')
#cat("   ", my.ConditionalMeanAndVar(x, data),'\n')
print(my.ConditionalMeanAndVar(x, data))
}
#data given
Joint = matrix(c(0.01,0.02,0.25,0.02,0.03,0.20,0.02,0.10,
0.05,0.15,0.10,0.05),nrow=4,ncol=3, byrow=TRUE)
my.ConditionalMeanAndVar = function(x, data)  {
x_data <- subset(data, X == x)
y_mean <- sum(x_data$Y * (x_data$Prob / sum(x_data$Prob)))
y_var <- sum((x_data$Y - y_mean)^ 2 * (x_data$Prob / sum(x_data$Prob)))
return(c(mean = y_mean, variance = y_var))
}
dim(Joint) <- c(4,3)
Joint
data <- data.frame(X = rep(1:3, each = 4), Y = rep(1:4, times=3), Prob = as.vector(Joint))
print.data.frame(data)
for(x in 1:3) {
cat("Mean & Variance of Y if X is equal to: ", x, "\n")
print(my.ConditionalMeanAndVar(x, data))
}
# Define the Joint Probabilities as a matrix
Joint = matrix(c(0.01,0.02,0.25,0.02,0.03,0.20,0.02,0.10,
0.05,0.15,0.10,0.05),nrow=4,ncol=3, byrow=TRUE)
# Define the function(x, matrix/data) to compute conditional
# mean and variance
my.ConditionalMeanAndVar = function(x, data)  {
# Subset the data to only include rows where X == x
x_data <- subset(data, X == x)
# Mean(Y|X=x) = Summa
y_mean <- x_data$Y * (x_data$Prob / sum(x_data$Prob))
y_var <- sum((x_data$Y - y_mean)^ 2 * (x_data$Prob / sum(x_data$Prob)))
return(c(mean = y_mean, variance = y_var))
}
# Printing the matrix of Joint Probabilities
dim(Joint) <- c(4,3)
Joint
# Create a data frame from the joint probabilities
# 3 columns - 'X' 'Y' 'Prob'
# X column repeats 1, 2, 3, each 4 times (12 rows) - (111122223...)
# Y column repeats (1, 2, 3, 4)  3 times (12 rows) - (123412341...)
# Prob column converts the 'Joint' matrix into a vector using the 'as.vector()'
data <- data.frame(X = rep(1:3, each = 4), Y = rep(1:4, times=3), Prob = as.vector(Joint))
print.data.frame(data)
# Printing Values
for(x in 1:3) {
cat("Mean & Variance of Y if X is equal to:", x, "\n")
print(my.ConditionalMeanAndVar(x, data))
}
# Define the Joint Probabilities as a matrix
Joint = matrix(c(0.01,0.02,0.25,0.02,0.03,0.20,0.02,0.10,
0.05,0.15,0.10,0.05),nrow=4,ncol=3, byrow=TRUE)
# Define the function(x, matrix/data) to compute conditional
# mean and variance
my.ConditionalMeanAndVar = function(x, data)  {
# Subset the data to only include rows where X == x
x_data <- subset(data, X == x)
# Mean(Y|X=x) = Summation of (Y * (Prob(Y|X=x) / Summation(Prob(Y|X=x))))
# Eg. (1 * 0.01/0.2 + 2 * 0.02/0.2 + 3 * 0.02/0.2 + 4 * 0.15/0.2)
y_mean <- sum(x_data$Y * (x_data$Prob / sum(x_data$Prob)))
# Variance(Y|X=x) = Summation of ((Y - y_mean)^2 * (Prob(Y|X=x) / Summation(Prob(Y|X=x))))
# Eg. ((1 - 3.55)^2 * (0.01/0.2) + (2 - 3.55)^2 * (0.02/0.2) + (3 - 3.55)^2 * (0.02/0.2))
#y_var <- sum((x_data$Y - y_mean)^2 * (x_data$Prob / sum(x_data$Prob)))
y_var <- sum((x_data$Y)^2 * (x_data$Prob / sum(x_data$Prob))) - y_mean
return(c(mean = y_mean, variance = y_var))
}
# Printing the matrix of Joint Probabilities
dim(Joint) <- c(4,3)
Joint
# Create a data frame from the joint probabilities
# 3 columns - 'X' 'Y' 'Prob'
# X column repeats 1, 2, 3, each 4 times (12 rows) - (111122223...)
# Y column repeats (1, 2, 3, 4)  3 times (12 rows) - (123412341...)
# Prob column converts the 'Joint' matrix into a vector using the 'as.vector()'
data <- data.frame(X = rep(1:3, each = 4), Y = rep(1:4, times=3), Prob = as.vector(Joint))
print.data.frame(data)
# Printing Values
for(x in 1:3) {
cat("Mean & Variance of Y if X is equal to:", x, "\n")
print(my.ConditionalMeanAndVar(x, data))
}
# Define the Joint Probabilities as a matrix
Joint = matrix(c(0.01,0.02,0.25,0.02,0.03,0.20,0.02,0.10,
0.05,0.15,0.10,0.05),nrow=4,ncol=3, byrow=TRUE)
# Define the function(x, matrix/data) to compute conditional
# mean and variance
my.ConditionalMeanAndVar = function(x, data)  {
# Subset the data to only include rows where X == x
x_data <- subset(data, X == x)
# Mean(Y|X=x) = Summation of (Y * (Prob(Y|X=x) / Summation(Prob(Y|X=x))))
# Eg. (1 * 0.01/0.2 + 2 * 0.02/0.2 + 3 * 0.02/0.2 + 4 * 0.15/0.2)
y_mean <- sum(x_data$Y * (x_data$Prob / sum(x_data$Prob)))
# Variance(Y|X=x) = Summation of ((Y - y_mean)^2 * (Prob(Y|X=x) / Summation(Prob(Y|X=x))))
# Eg. ((1 - 3.55)^2 * (0.01/0.2) + (2 - 3.55)^2 * (0.02/0.2) + (3 - 3.55)^2 * (0.02/0.2))
#y_var <- sum((x_data$Y - y_mean)^2 * (x_data$Prob / sum(x_data$Prob)))
y_var <- sum((x_data$Y)^2 * (x_data$Prob / sum(x_data$Prob))) - y_mean^2
return(c(mean = y_mean, variance = y_var))
}
# Printing the matrix of Joint Probabilities
dim(Joint) <- c(4,3)
Joint
# Create a data frame from the joint probabilities
# 3 columns - 'X' 'Y' 'Prob'
# X column repeats 1, 2, 3, each 4 times (12 rows) - (111122223...)
# Y column repeats (1, 2, 3, 4)  3 times (12 rows) - (123412341...)
# Prob column converts the 'Joint' matrix into a vector using the 'as.vector()'
data <- data.frame(X = rep(1:3, each = 4), Y = rep(1:4, times=3), Prob = as.vector(Joint))
print.data.frame(data)
# Printing Values
for(x in 1:3) {
cat("Mean & Variance of Y if X is equal to:", x, "\n")
print(my.ConditionalMeanAndVar(x, data))
}
# Define the Joint Probabilities as a matrix
Joint = matrix(c(0.01,0.02,0.25,0.02,0.03,0.20,0.02,0.10,
0.05,0.15,0.10,0.05),nrow=4,ncol=3, byrow=TRUE)
# Define the function(x, matrix/data) to compute conditional mean and variance
my.ConditionalMeanAndVar = function(x, data)  {
# Subset the data to only include rows where X == x
x_data <- subset(data, X == x)
# Mean(Y|X=x) = Summation of (Y * (Prob(Y|X=x) / Summation(Prob(Y|X=x))))
# Eg. (1 * 0.01/0.2 + 2 * 0.02/0.2 + 3 * 0.02/0.2 + 4 * 0.15/0.2)
y_mean <- sum(x_data$Y * (x_data$Prob / sum(x_data$Prob)))
# Variance(Y|X=x) = Summation of ((Y - y_mean)^2 * (Prob(Y|X=x) / Summation(Prob(Y|X=x))))
# Eg. ((1 - 3.55)^2 * (0.01/0.2) + (2 - 3.55)^2 * (0.02/0.2) +
#      (3 - 3.55)^2 * (0.02/0.2) + (4 - 3.55)^2 * (0.15/0.2))
y_var <- sum((x_data$Y - y_mean)^2 * (x_data$Prob / sum(x_data$Prob)))
# Variance(Y|X=x) = Summation of (Y^2 * (Prob(Y|X=x) / Summation(Prob(Y|X=x)))) - y_mean^2
# Eg. (1^2 * 0.01/0.2 + 2^2 * 0.02/0.2 + 3^2 * 0.02/0.2 + 4^2 * 0.15/0.2) - 3.55^2
#y_var <- sum((x_data$Y)^2 * (x_data$Prob / sum(x_data$Prob))) - y_mean^2
# Return the results as a named vector
return(c(mean = y_mean, variance = y_var))
}
# Printing the matrix of Joint Probabilities
dim(Joint) <- c(4,3)
Joint
# Create a data frame from the joint probabilities
# 3 columns - 'X' 'Y' 'Prob'
# X column repeats 1, 2, 3, each 4 times (12 rows) - (111122223...)
# Y column repeats (1, 2, 3, 4)  3 times (12 rows) - (123412341...)
# Prob column converts the 'Joint' matrix into a vector using the 'as.vector()'
data <- data.frame(X = rep(1:3, each = 4), Y = rep(1:4, times=3), Prob = as.vector(Joint))
print.data.frame(data)
# Printing Values
for(x in 1:3) {
cat("Mean & Variance of Y if X is equal to:", x, "\n")
print(my.ConditionalMeanAndVar(x, data))
}
hist(x) ; boxplot(x); and qqnorm(x), qqline(x,col=“red”,lwd=2)
hist(x) ; boxplot(x); qqnorm(x), qqline(x,col=“red”,lwd=2)
hist(x) ; boxplot(x); qqnorm(x); qqline(x,col=“red”,lwd=2)
hist(x) ; boxplot(x); qqnorm(x) qqline(x,col=“red”,lwd=2)
hist(x) ; boxplot(x); qqnorm(x); qqline(x,col=“red”,lwd=2)
qqline(x,col=“red”,lwd=2)
qqline(x, col=“red”, lwd=2)
qqline(x, col='red', lwd=2)
x <- rnorm(n=1000, mean=15, sd=3)
y <- rchisq(n=1000, df=4)
hist(x)
boxplot(x)
qqnorm(x)
qqline(x, col='red', lwd=2)
x <- rnorm(n=1000, mean=15, sd=3)
hist(x)
boxplot(x)
qqnorm(x)
qqline(x, col='red', lwd=2)
qqnorm(x)
# set the seed
set.seed(393)
# generates a random sample of 1000 values from a normal distribution
# with a mean of 15 and a standard deviation of 3, stored in x
x <- rnorm(n=1000, mean=15, sd=3)
# creates a histogram of the 'x' data
hist(x)
# creates a boxplot of the 'x' data
boxplot(x)
# creates a normal probability plot of the 'x' data
qqnorm(x)
# set the seed
set.seed(393)
# generates a random sample of 1000 values from a normal distribution
# with a mean of 15 and a standard deviation of 3, stored in x
x <- rnorm(n=1000, mean=15, sd=3)
# creates a histogram of the 'x' data
hist(x)
# creates a boxplot of the 'x' data
boxplot(x)
# creates a normal probability plot of the 'x' data
qqnorm(x)
# adds a red reference line to the previous plot,
# aids in assessing the normality of the 'x' data
qqline(x, col='red', lwd=2)
# set the seed
set.seed(393)
# generates a random sample of 1000 values from a chi-squared
# distribution with 4 degrees of freedom, stored in y
y <- rchisq(n=1000, df=4)
# creates a histogram of the 'y' data
hist(y)
# creates a boxplot of the 'y' data
boxplot(y)
# creates a normal probability plot of the 'y' data
qqnorm(y)
# set the seed
set.seed(393)
# generates a random sample of 1000 values from a chi-squared
# distribution with 4 degrees of freedom, stored in y
y <- rchisq(n=1000, df=4)
# creates a histogram of the 'y' data
hist(y)
# creates a boxplot of the 'y' data
boxplot(y)
# creates a normal probability plot of the 'y' data
qqnorm(y)
# adds a blue reference line to the previous plot,
# aids in assessing the normality of the 'y' data
qqline(y,col='blue',lwd=2)
setwd("C:/Users/HP/OneDrive/Desktop/CODING/Year 2/Stats & Probability")
# Central Limit Theorem (CLT) Proof
# initialize var to store sample means
x.bar = 0
# set the seed
set.seed(393)
# generates a random sample of 700 values from a chi-squared
# distribution with 4 degrees of freedom, stored in popu.x
# population from which samples will be drawn
popu.x <- rchisq(n = 700, df = 4)
#
for (j in 1:3) {
samp.size = 80 * j
for(i in 1:3000)  {
samp.x = sample(popu.x, size = samp.size, replace = TRUE)
x.bar[i] = mean(samp.x)
}
# Population Distribution
hist(popu.x)
# Sampling Distribution
hist(x.bar)
# Rule1 Proof
xb.mean = mean(x.bar)
pop.mean = mean(popu.x)
# Rule2 Proof
xb.sd = sd(x.bar)
pop.sd = sd(popu.x)/sqrt(samp.size)
cat('Mean xb', j, '=', xb.mean)
cat('Mean pop', j, '=', pop.mean)
cat('SD xb', j, '=', xb.sd)
cat('SD pop', j, '=', pop.sd)
}
# Central Limit Theorem (CLT) Proof
# initialize var to store sample means
x.bar = 0
# set the seed
set.seed(393)
# generates a random sample of 700 values from a chi-squared
# distribution with 4 degrees of freedom, stored in popu.x
# population from which samples will be drawn
popu.x <- rchisq(n = 700, df = 4)
#
for (j in 1:3) {
samp.size = 80 * j
for(i in 1:3000)  {
samp.x = sample(popu.x, size = samp.size, replace = TRUE)
x.bar[i] = mean(samp.x)
}
# Population Distribution
hist(popu.x)
# Sampling Distribution
hist(x.bar)
# Rule1 Proof
xb.mean = mean(x.bar)
pop.mean = mean(popu.x)
# Rule2 Proof
xb.sd = sd(x.bar)
pop.sd = sd(popu.x)/sqrt(samp.size)
cat('Mean xb', j, '=', xb.mean, '\n')
cat('Mean pop', j, '=', pop.mean, '\n')
cat('SD xb', j, '=', xb.sd, '\n')
cat('SD pop', j, '=', pop.sd, '\n')
}
# Central Limit Theorem (CLT) Proof
# initialize var to store sample means
x.bar = 0
# set the seed
set.seed(393)
# generates a random sample of 700 values from a chi-squared
# distribution with 4 degrees of freedom, stored in popu.x
# population from which samples will be drawn
popu.x <- rchisq(n = 700, df = 4)
#
for (j in 1:5) {
samp.size = 80 * j
for(i in 1:3000)  {
samp.x = sample(popu.x, size = samp.size, replace = TRUE)
x.bar[i] = mean(samp.x)
}
# Population Distribution
hist(popu.x)
# Sampling Distribution
hist(x.bar)
# Rule1 Proof
xb.mean = mean(x.bar)
pop.mean = mean(popu.x)
# Rule2 Proof
xb.sd = sd(x.bar)
pop.sd = sd(popu.x)/sqrt(samp.size)
cat('Mean xb', j, '=', xb.mean, '\n')
cat('Mean pop', j, '=', pop.mean, '\n')
cat('SD xb', j, '=', xb.sd, '\n')
cat('SD pop', j, '=', pop.sd, '\n\n')
}
# Central Limit Theorem (CLT) Proof
# initialize var to store sample means
x.bar = 0
# set the seed
set.seed(393)
# generates a random sample of 700 values from a chi-squared
# distribution with 4 degrees of freedom, stored in popu.x
# population from which samples will be drawn
popu.x <- rchisq(n = 700, df = 4)
#
for (j in 1:5) {
samp.size = 80 * j
for(i in 1:3000)  {
samp.x = sample(popu.x, size = samp.size, replace = TRUE)
x.bar[i] = mean(samp.x)
}
# Population Distribution
hist(popu.x)
# Sampling Distribution
hist(x.bar)
# Rule1 Proof
xb.mean = mean(x.bar)
pop.mean = mean(popu.x)
mean.diff = abs(xb.mean - pop.mean)
# Rule2 Proof
xb.sd = sd(x.bar)
pop.sd = sd(popu.x)/sqrt(samp.size)
sd.diff = abs(xb.sd - pop.sd)
cat('Mean xb', j, '=', xb.mean, '\n')
cat('Mean pop', j, '=', pop.mean, '\n')
cat('Mean difference', j, '=', mean.diff, '\n')
cat('SD xb', j, '=', xb.sd, '\n')
cat('SD pop', j, '=', pop.sd, '\n')
cat('SD difference', j, '=', sd.diff, '\n\n')
}
# Central Limit Theorem (CLT) Proof
# initialize var to store sample means
x.bar = 0
# set the seed
set.seed(393)
# generates a random sample of 700 values from a chi-squared
# distribution with 4 degrees of freedom, stored in popu.x
# population from which samples will be drawn
popu.x <- rchisq(n = 700, df = 4)
#
for (j in 1:4) {
samp.size = 80 * j
for(i in 1:3000)  {
samp.x = sample(popu.x, size = samp.size, replace = TRUE)
x.bar[i] = mean(samp.x)
}
# Population Distribution
hist(popu.x)
# Sampling Distribution
hist(x.bar)
# Rule1 Proof
xb.mean = mean(x.bar)
pop.mean = mean(popu.x)
mean.diff = abs(xb.mean - pop.mean)
# Rule2 Proof
xb.sd = sd(x.bar)
pop.sd = sd(popu.x)/sqrt(samp.size)
sd.diff = abs(xb.sd - pop.sd)
cat('Mean xb', j, '=', xb.mean, '\n')
cat('Mean pop', j, '=', pop.mean, '\n')
cat('Mean difference', j, '=', mean.diff, '\n\n')
cat('SD xb', j, '=', xb.sd, '\n')
cat('SD pop', j, '=', pop.sd, '\n')
cat('SD difference', j, '=', sd.diff, '\n\n\n')
}
# Central Limit Theorem (CLT) Proof
# initialize var to store sample means
x.bar = 0
# set the seed
set.seed(393)
# generates a random sample of 700 values from a chi-squared
# distribution with 4 degrees of freedom, stored in popu.x
# population from which samples will be drawn
popu.x <- rchisq(n = 700, df = 4)
# loop over different sample sizes
for (j in 1:4) {
# set sample size to 80 * loop index
samp.size = 80 * j
# loop over each sample size and calculate sample means
for(i in 1:3000)  {
# each iteration, it takes a random sample of size samp.size
# with replacement from the population
samp.x = sample(popu.x, size = samp.size, replace = TRUE)
# stores the calculated mean at the current interation 'i'
x.bar[i] = mean(samp.x)
}
# Population Distribution
hist(popu.x)
# Sampling Distribution
hist(x.bar)
# Rule1 Proof
# mean of the sampling distribution
# should be equal to the mean of the population.
xb.mean = mean(x.bar)
pop.mean = mean(popu.x)
# calculate mean difference between sampling distribution
# and population distribution
mean.diff = abs(xb.mean - pop.mean)
# Rule2 Proof
# standard deviation of the sampling distribution
# should be equal to the standard deviation of the population
# divided by the square root of the sample size
xb.sd = sd(x.bar)
pop.sd = sd(popu.x)/sqrt(samp.size)
# calculate standard deviation difference between sampling distribution
# and population distribution, scaled by the square root of the sample size
sd.diff = abs(xb.sd - pop.sd)
# print mean and standard deviation differences for each sample size
cat('Mean of Sample', j, '=', xb.mean, '\n')
cat('Mean of Population', j, '=', pop.mean, '\n')
cat('Mean Difference', j, '=', mean.diff, '\n\n')
cat('SD of Sample', j, '=', xb.sd, '\n')
cat('SD of Population', j, '=', pop.sd, '\n')
cat('SD Difference', j, '=', sd.diff, '\n\n\n')
}
